<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Liby">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Liby">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Liby">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Liby </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Liby</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/30/封装cookie/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://og48zuyzv.bkt.clouddn.com/t01fad4ace94b4e1dd0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/30/封装cookie/" itemprop="url">
                  JS之封装cookie操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-30T17:59:30+08:00">
                2017-08-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原生js中，我们通过<code>document.cookie</code>可以获取<code>cookie</code>，这样我们可以不用考虑兼容性，但是增，删，查我们最好通过封装的形式把他们区分开来，使得我们能够像操作对象一样去操作cookie，这样使用起来也直观方便，底层还是基于document.cookie来操作。</p>
<p>下面直接上代码加注释：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用闭包将代码包起来，避免引入时污染全局作用域</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">global</span>)</span>&#123;</div><div class="line">    <span class="comment">//获取cookie对象，格式化成对象形式</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getCookiesObj</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> cookies = &#123;&#125;;</div><div class="line">        <span class="keyword">if</span>(<span class="built_in">document</span>.cookie)&#123;</div><div class="line">            <span class="keyword">var</span> objs = <span class="built_in">document</span>.cookie.split(<span class="string">';'</span>);</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> objs)&#123;</div><div class="line">                <span class="keyword">var</span> index = objs[i].indexOf(<span class="string">'='</span>);</div><div class="line">                <span class="keyword">var</span> key = objs[i].substr(<span class="number">0</span>,index);</div><div class="line">                <span class="keyword">var</span> value = objs[i].substr(index+<span class="number">1</span>,objs[i].length);</div><div class="line">                cookies[key] = value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cookie;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//获取cookie</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">key</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">decodeURIComponent</span>(getCookiesObj()[key]) || <span class="literal">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置cookie</span></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">name,value,opts</span>)</span>&#123;</div><div class="line">        <span class="comment">//opts: maxAge,path,domain,secure</span></div><div class="line">        <span class="keyword">if</span>(name &amp;&amp; value)&#123;</div><div class="line">            <span class="keyword">var</span> cookie = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(value);</div><div class="line">            <span class="keyword">if</span>(opts)&#123;</div><div class="line">                <span class="keyword">if</span>(opts.maxAge)&#123;</div><div class="line">                    cookie += <span class="string">';max-age='</span> + opts.maxAge;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(opts.path)&#123;</div><div class="line">                    cookie += <span class="string">';max-age='</span> + opts.path;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(opts.domain)&#123;</div><div class="line">                    cookie += <span class="string">';max-age='</span> + opts.doamin;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(opts.secure)&#123;</div><div class="line">                    cookie += <span class="string">';max-age='</span> + opts.secure;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">document</span>.cookie = cookie;</div><div class="line">            <span class="keyword">return</span> cookie;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">''</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">key</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(getCookiesObj()[key])&#123;</div><div class="line">            <span class="built_in">document</span>.cookie = key + <span class="string">'=;max-age=0'</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">clear</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> cookies = getCookiesObj();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> cookies)&#123;</div><div class="line">            <span class="built_in">document</span>.cookie = cookies[i] + <span class="string">'=;max-age=0'</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    global[<span class="string">'cookie'</span>] = &#123;</div><div class="line">        <span class="string">'getCookiesObj'</span>: getCookiesObj,</div><div class="line">        <span class="string">'set'</span>: set,</div><div class="line">        <span class="string">'get'</span>: get,</div><div class="line">        <span class="string">'remove'</span>: remove,</div><div class="line">        <span class="string">'clear'</span>: clear</div><div class="line">    &#125;</div><div class="line">&#125;)(<span class="built_in">window</span>)</div></pre></td></tr></table></figure></p>
<p>封装好后，我们只要导入这个文件，就可以用全局变量的方式去操作cookie了！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/30/封装ajax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://og48zuyzv.bkt.clouddn.com/t01fad4ace94b4e1dd0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/30/封装ajax/" itemprop="url">
                  JS之封装AJAX
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-30T00:54:15+08:00">
                2017-08-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前端中对于ajax的使用越来越多，原生的ajax需要考虑兼容性，写法也较为复杂，所以打算自己封装一个。</p>
<h2 id="原生ajax"><a href="#原生ajax" class="headerlink" title="原生ajax"></a>原生ajax</h2><p>原生ajax的使用可以分为4个步骤(3的位置不是固定的，只要在1后面即可)：</p>
<ol>
<li>新建一个<code>XHR对象</code></li>
<li>用<code>open（）</code>方法指定请求方法，请求资源和是否异步</li>
<li>为XHR对象绑定一个<code>onreadystatechange函数</code></li>
<li>用<code>send（）</code>发送请求</li>
</ol>
<p>下面一一介绍：</p>
<h3 id="新建XHR对象"><a href="#新建XHR对象" class="headerlink" title="新建XHR对象"></a>新建XHR对象</h3><p>创建XHR对象很简单，一行代码搞定：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div></pre></td></tr></table></figure></p>
<p>考虑要兼容IE浏览器，得像下面这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>（<span class="built_in">window</span>.XMLHttpRequest）&#123;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="指定open（）方法"><a href="#指定open（）方法" class="headerlink" title="指定open（）方法"></a>指定open（）方法</h3><p>当我们要跟服务器交互的时候，就需要像正常的http请求那样指定请求方式和请求的资源，这里XHR提供了一个open（）方法，它可以接受3个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">open(method,url,<span class="keyword">async</span>)</div><div class="line">method:请求的类型，常见的有GET和POST</div><div class="line">url：请求资源的路径</div><div class="line"><span class="keyword">async</span>：<span class="literal">true</span>（异步）或者<span class="literal">false</span>（同步）</div></pre></td></tr></table></figure></p>
<h3 id="绑定回调函数"><a href="#绑定回调函数" class="headerlink" title="绑定回调函数"></a>绑定回调函数</h3><p>当我们获取到资源时，我们希望能够通过回调的方式来处理它，这时就需要指定onreadystatechange方法了。在这之前，我们需要先了解两个东西，<code>readyState</code>和<code>status</code>。</p>
<p>首先是redayState，它一共有5个可能的值，代表的是<code>请求的建立</code>到<code>成功接受响应</code>的一系列过程：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>：请求未初始化</div><div class="line"><span class="number">1</span>：与服务器连接已建立</div><div class="line"><span class="number">2</span>：请求被接受</div><div class="line"><span class="number">3</span>：请求处理中</div><div class="line"><span class="number">4</span>：请求完成，且返回响应信息</div></pre></td></tr></table></figure></p>
<p>每当xhr对象的<code>readyState改变</code>时，<code>onreadystatechange事件就会被触发</code>，从单词也很明显能看出了把！这样xhr请求的过程中，onreadystatechange事件就会被触发5次，一般我们只会判断<strong>readyState是否为4</strong>，因为这时候我们已经拿到了服务器的返回的信息（可能是资源也可能是其他）。</p>
<p>但是拿到了响应信息并不代表我们的请求就成功了，与服务器交互的结果有可能是404页面未找到，也有可能是500服务器内部错误等其他情况，这时候就需要通过另一个判断条件–<code>status</code>来判断了<br>常见的状态码有这些：</p>
<ul>
<li>200 请求成功</li>
<li>301 永久重定向</li>
<li>302 临时重定向</li>
<li>304 使用缓存（条件请求If-Modified-Since）</li>
<li>400 请求出现语法错误</li>
<li>401 用户未认证（不能靠这个状态码来确定用户是否认证）</li>
<li>403 资源不可用</li>
<li>404 页面未找到</li>
<li>500 服务器内部错误</li>
</ul>
<p>当readyState为4且status为200时，我们就可以提取数据了，提取数据可以通过2个属性：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">responseText：获得字符串形式的响应数据</div><div class="line">responseXML: 获得XML格式的响应数据</div></pre></td></tr></table></figure></p>
<h3 id="调用send（）发送请求"><a href="#调用send（）发送请求" class="headerlink" title="调用send（）发送请求"></a>调用send（）发送请求</h3><p>当我们使用post请求时，要发给服务端的数据要通过’&amp;’连接放在send（）方法里</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.send(data)</div></pre></td></tr></table></figure>
<h2 id="ajax封装"><a href="#ajax封装" class="headerlink" title="ajax封装"></a>ajax封装</h2><p>整合以上代码并添加一些判断以及处理函数，我们自己封装的ajax就成了！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">* 调用形式：</div><div class="line">*   $.ajax(&#123;</div><div class="line">*     url: '.',</div><div class="line">*     type: 'POST',</div><div class="line">*     data: &#123;</div><div class="line">*         name: 'liby',</div><div class="line">*         height: '172'</div><div class="line">*     &#125;</div><div class="line">*     success: function(res)&#123;</div><div class="line">*         //回调代码</div><div class="line">*     &#125;,</div><div class="line">*     fail： function(status)&#123;</div><div class="line">*         //失败的回调代码</div><div class="line">*     &#125;</div><div class="line">*   &#125;)</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">var</span> $ = &#123;</div><div class="line">    <span class="attr">ajax</span>: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">        <span class="comment">//处理传递过来的数据,拼接成'a=1&amp;b=2'的形式</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">formatData</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> result = <span class="string">''</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</div><div class="line">                result += <span class="built_in">encodeURIComponent</span>(key) + <span class="string">'='</span> + <span class="built_in">encodeURIComponent</span>(obj[key]) + <span class="string">'&amp;'</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result.slice(<span class="number">0</span>,<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果传递进来的不是对象或者为空，直接return</span></div><div class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span> || tpeof obj != <span class="string">'object'</span>)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//获取传递的参数</span></div><div class="line">        <span class="keyword">var</span> type = obj.type;</div><div class="line">        <span class="keyword">var</span> url = obj.url;</div><div class="line">        <span class="keyword">var</span> <span class="keyword">async</span> = (obj.async == <span class="literal">undefined</span> || obj.async)?<span class="literal">true</span>:<span class="literal">false</span>;</div><div class="line">        <span class="keyword">var</span> data = formatData(obj.data);</div><div class="line">        <span class="keyword">var</span> success = obj.success || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">        <span class="keyword">var</span> fail = obj.fail || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">        <span class="comment">//新建xhr对象，兼容IE</span></div><div class="line">        <span class="keyword">if</span>（<span class="built_in">window</span>.XMLHttpRequest）&#123;</div><div class="line">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">var</span> xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>);</div><div class="line">        &#125; </div><div class="line">        <span class="comment">//绑定回调函数</span></div><div class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="keyword">if</span>(xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>)&#123;</div><div class="line">                <span class="keyword">var</span> result = <span class="literal">null</span>;</div><div class="line">                <span class="keyword">var</span> resultType = xhr.getResponseHeader(<span class="string">'Content-Type'</span>);</div><div class="line">                <span class="keyword">if</span>(resultType.indexOf(<span class="string">"json"</span>) != <span class="number">-1</span>)&#123;</div><div class="line">                    result = <span class="built_in">JSON</span>.parse(xhr.responseText);</div><div class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(resultType.indexOf(<span class="string">"xml"</span>) != <span class="number">-1</span>)&#123;</div><div class="line">                    result = xhr.responseXML;</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    result = xhr.responseText;</div><div class="line">                &#125;</div><div class="line">                success(result);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                fail(xhr.status);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 根据请求方式设置open方法和send方法，发送请求</span></div><div class="line">        <span class="keyword">if</span>(type == <span class="string">'get'</span>)&#123;</div><div class="line">            url = url + <span class="string">'?'</span> + data;</div><div class="line">            xhr.open(type, url, <span class="keyword">async</span>);</div><div class="line">            xhr.send(<span class="literal">null</span>);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            xhr.open(type, url, <span class="keyword">async</span>);</div><div class="line">            <span class="comment">//设置提交表单的内容类型</span></div><div class="line">            xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>);</div><div class="line">            xhr.send(data);</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/06/事件的那些事/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://og48zuyzv.bkt.clouddn.com/t01fad4ace94b4e1dd0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/06/事件的那些事/" itemprop="url">
                  JS事件的那些事
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T17:06:23+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前已经有博客介绍了js的事件，下面的作为补充。</p>
<h2 id="为何移动端点击会有0-3s的延迟"><a href="#为何移动端点击会有0-3s的延迟" class="headerlink" title="为何移动端点击会有0.3s的延迟"></a>为何移动端点击会有0.3s的延迟</h2><p>移动端设备会有这样的现象，就是移动端页面对于触摸事件会有<strong>300ms</strong>的延迟，据研究表明，当延迟超过100ms时，用户就能感受到明显的卡顿，当延迟达到300ms，用户更能感受到界面响应速度的缓慢。</p>
<blockquote>
<p>其实这应该追溯到手机开始支持<strong>双击缩放</strong>的时候了，ios上的safari为了能将pc端的大网页较好的展示在手机端上，开始使用双击缩放的方案。通过双击缩放，我们能够看清原本因为尺寸太小而看不清楚的字体，图片等。虽然这为我们带来了便利，但在另一方面却造成了困扰，要支持这个功能，浏览器就必须判断用户是否在极短的事件内双击，就算你只是想点击一个按钮，浏览器也会按照惯例等待300ms的时间来确定用户到底是不是要缩放页面，这也就是延迟的由来。</p>
</blockquote>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="使用fastclick-js"><a href="#使用fastclick-js" class="headerlink" title="使用fastclick.js"></a>使用fastclick.js</h4><p>fastclick的使用方法简单，在window load事件后，在body上调用fastClick.attach（）即可<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.addEventListener(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    FastClick.attach(<span class="built_in">document</span>.body);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>当 FastClick 检测到当前页面使用meta设置了user-scalable=no或者 touch-action 属性的解决方案时，会静默退出.</p>
</blockquote>
<h4 id="jQuery和zepto-js则使用tap事件取代click事件"><a href="#jQuery和zepto-js则使用tap事件取代click事件" class="headerlink" title="jQuery和zepto.js则使用tap事件取代click事件"></a>jQuery和zepto.js则使用tap事件取代click事件</h4><p>tap事件的大致思路：</p>
<ul>
<li>在touchstart/touchend时记录时间，手指位置</li>
<li>在touchend时进行比较，确认是否为同一位置（或允许较小的位移）</li>
<li>判断时间间隔（一般为200ms）</li>
<li>过程未曾触发touchmove，即认为触发移动端的’click’，成为’tap’</li>
</ul>
<h4 id="meta-viewport"><a href="#meta-viewport" class="headerlink" title="meta viewport"></a>meta viewport</h4><p>meta viewport中指定页面不可缩放，则click时不存在300ms延迟</p>
<h2 id="mouseenter-mouseleave-和-mouseover-mouseout"><a href="#mouseenter-mouseleave-和-mouseover-mouseout" class="headerlink" title="mouseenter/mouseleave 和 mouseover/mouseout"></a>mouseenter/mouseleave 和 mouseover/mouseout</h2><p>区别：</p>
<ul>
<li>mouseover，mouseout可冒泡，mouseenter，mouseleave不可冒泡</li>
<li>mouseenter只作用于<strong>目标元素</strong>，进入子元素返回不能再触发（进入只触发一次）</li>
<li>mouseover作用于<strong>目标元素及后代元素</strong>，进入子元素返回可再触发父元素的事件(mouseout)（可多次触发）</li>
<li>mouseleave与mouseenter类似，各自只触发自己的事件</li>
<li>mouseout与mouseover类似，进入子元素可触发父元素的事件(mouseover)</li>
</ul>
<p>在<code>mouseover/mouseout</code>看来，它的事件都<strong>与后代元素有关</strong>，<strong>进入子元素</strong>和<strong>从子元素移出</strong>会触发父元素相应的<strong>mouseout</strong>和<strong>mouseover</strong>，且子元素事件会冒泡；而在<code>mouseenter/mouseleave</code>中，一旦进入了元素，无论是子元素或者父元素，都看作<strong>单独的个体</strong>，各自触发事件且<strong>不会冒泡</strong>，从父元素进入子元素和从子元素移出到父元素都不会触发父元素的事件。</p>
<blockquote>
<p>总结：这两组事件的区别总结起来就是：是否冒泡和子元素的移入移出是否会触发父元素的事件。牢记这两点就ok了！</p>
</blockquote>
<h2 id="clientX-clientY-和-pageX-pageY"><a href="#clientX-clientY-和-pageX-pageY" class="headerlink" title="clientX/clientY 和 pageX/pageY"></a>clientX/clientY 和 pageX/pageY</h2><p>当我们通过鼠标触发页面的鼠标事件时，就会产生一个事件对象e并传给我们绑定的事件函数，里面包含很多的内容。</p>
<p>通常鼠标操作的话，主要是要获取<strong>鼠标当前的坐标值</strong>，并利用坐标值经过一系列的计算来完成我们的目的，例如：音乐播放器的进度条的拉拽，页面上元素的拖拽以及边界的判断等等。</p>
<p>而事件对象e中就提供了很多有用的信息：最常用的还是clientX/clientY 和 pageX/pageY这两组属性。</p>
<p>client表示的是<code>页面的可视区域（即当前浏览器窗口）</code>，而page表示的则是<code>整个页面（包括超出窗口宽高的部分）</code>。</p>
<p>这样就很明了了，在没发生滚动的情况下，两组属性随便你选，但是一旦发生滚动，还是需要选择page开头的属性，才能获得正确的数据。</p>
<blockquote>
<p>兼容性：IE不支持，需要用event.y和event.y获取</p>
</blockquote>
<p>除了上面两组属性外，通过鼠标触发的事件e中还有screenX和screenY，不过不是很常用，就不解释了。</p>
<h2 id="DOM0和DOM2级事件的区别"><a href="#DOM0和DOM2级事件的区别" class="headerlink" title="DOM0和DOM2级事件的区别"></a>DOM0和DOM2级事件的区别</h2><h3 id="Dom0级事件"><a href="#Dom0级事件" class="headerlink" title="Dom0级事件"></a>Dom0级事件</h3><p>dom0级有两种形式：</p>
<ul>
<li>在标签内绑定事件，如‘onclick=fn（）’</li>
<li>在js中用‘onclick=function(){}’的形式绑定</li>
</ul>
<p>看看下面的例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">'test'</span> <span class="attr">href</span>=<span class="string">'javascript:void(0);'</span> <span class="attr">onclick</span>=<span class="string">'alert(click)'</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line">//js</div><div class="line">var oTest = document.getElementById('oTest');</div><div class="line">oTest.onclick = function()&#123;</div><div class="line">    alert('testing...')</div><div class="line">&#125;</div><div class="line">oTest.onclick = function()&#123;</div><div class="line">    alert('finished!')</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的例子执行后，你会发现只会弹出finished字样的提示框，这是因为同一类型的事件只能绑定一个，后面会覆盖前面的。</p>
<h3 id="Dom2级事件"><a href="#Dom2级事件" class="headerlink" title="Dom2级事件"></a>Dom2级事件</h3><p>Dom2级事件有两个方法：addEventListener()和removeEventListener()，</p>
<p>都可传入3个参数：</p>
<ul>
<li>事件名，不需要加on</li>
<li>事件函数</li>
<li>capture标识，true或false，默认false（冒泡）</li>
</ul>
<p>我们将上面例子用Dom2级改写后就能顺序输出testing和finished字样了：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">'test'</span> <span class="attr">href</span>=<span class="string">'javascript:void(0);'</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"></div><div class="line">//js</div><div class="line">var oTest = document.getElementById('oTest');</div><div class="line">oTest.addEventListener('click', function()&#123;</div><div class="line">    alert('testing...')</div><div class="line">&#125;)</div><div class="line">oTest.addEventListener('click', function()&#123;</div><div class="line">    alert('finished!')</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<blockquote>
<p>移除事件时需要传入和绑定事件时完全相同的参数，所以<code>匿名函数</code>绑定的事件不能被移除</p>
</blockquote>
<p>IE 通过attachEvent()和detachEvent()来支持，只传入事件名(<strong>要加on前缀</strong>)和处理函数，<code>只支持冒泡</code>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/04/js深浅拷贝/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://og48zuyzv.bkt.clouddn.com/t01fad4ace94b4e1dd0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/04/js深浅拷贝/" itemprop="url">
                  JS之深浅拷贝
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-04T23:56:15+08:00">
                2017-08-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="浅拷贝导致的问题"><a href="#浅拷贝导致的问题" class="headerlink" title="浅拷贝导致的问题"></a>浅拷贝导致的问题</h2><p>js中我们有时候需要对数组或者对象这些复杂类型进行拷贝，当我们把他们赋予其他变量时就以为万事大吉了，可实际上当我们对改变这些变量时，原来的数组或者对象也会跟着改变，如下面的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = a;</div><div class="line">arr[<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a[<span class="number">1</span>]);<span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(arr[<span class="number">1</span>]);<span class="comment">//1</span></div><div class="line"><span class="built_in">console</span>.log(a=arr);<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>是的，最后打印出来的都会是相同的结果，这也证明了我们的拷贝与原来的对象并不是完全分离的，这其实是浅拷贝导致的问题。</p>
<p>但是有时候我们想要获得跟原对象完全不相干的拷贝，那应该怎么办呢，这时候就需要深拷贝了</p>
<h2 id="深浅拷贝的原理及区别"><a href="#深浅拷贝的原理及区别" class="headerlink" title="深浅拷贝的原理及区别"></a>深浅拷贝的原理及区别</h2><h3 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h3><p>ECMAScript中类型变量分为两类：</p>
<ul>
<li>基本数据类型：number/string/boolean/undefined/null/symbol（ES6新增）</li>
<li>引用数据类型：object/Array/Date/Function等</li>
</ul>
<p>平时我们总听说堆栈，其实他们就是用来储存我们的变量和值的。</p>
<h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h3><p>对于<strong>基本数据类型</strong>而言，它们是保存在<strong>栈内存</strong>里面的，包含<strong>变量名</strong>及<strong>对应的值</strong>。<br>结构大致如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">55</td>
</tr>
</tbody>
</table>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p><strong>引用类型</strong>则是保存在<strong>堆内存</strong>中，栈内存中会保存有<strong>变量名</strong>以及<strong>引用类型在堆内存中的地址</strong>。当我们访问引用类型时，会先通过变量名在栈内存中找到<strong>对象在堆内存中的地址指针</strong>，然后再到相应的堆内存中查找数据。<br>现在栈内存的结构是这样的：</p>
<p><code>栈内存</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">变量</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">堆地址1</td>
</tr>
</tbody>
</table>
<p><code>堆内存</code></p>
<p>栈内存中的堆地址1 —&gt; 对内存中的obj1</p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">obj1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>栈内存中存放的必须时大小固定的数据，而引用类型大小不固定，只能存放在堆中。基本数据类型是按值访问，而引用类型是按地址访问。</p>
</blockquote>
<h3 id="基本类型的复制"><a href="#基本类型的复制" class="headerlink" title="基本类型的复制"></a>基本类型的复制</h3><p>对于基本类型来说，当拷贝时，会将值也一同复制给新变量，当我们修改它时，是下面这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> b = a;</div><div class="line">b = <span class="number">2</span>;</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>从上面也可以看出，修改b后，并不会影响到a的值，因为它们是相互独立的。</p>
<blockquote>
<p>栈内存中对于相同的基本数据类型值只会保存一份，并不会存放两个1，如果两个变量都指向1，那么他们就是相等的，指向不同值，则是不等（变量相互独立）的。函数参数的按值传递跟上面的例子原理一样，所以函数内就算重新修改了新变量也不会改变原来的变量。</p>
</blockquote>
<h3 id="引用类型的复制"><a href="#引用类型的复制" class="headerlink" title="引用类型的复制"></a>引用类型的复制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = a;</div><div class="line">b.push(<span class="number">4</span>);</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//[1,2,3,4]</span></div><div class="line"><span class="built_in">console</span>.log(b);<span class="comment">//[1,2,3,4]</span></div></pre></td></tr></table></figure>
<p>虽然我们的本意是只想对拷贝后的b进行修改，但是由于我们拷贝的只是a的引用类型地址，所以其实他们指向的是同一个对象，这时候无论对谁进行修改都会导致两者都发生变化。</p>
<p>###深浅拷贝<br>聪明的你一定会想到下面这种方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;a.length;i++)&#123;</div><div class="line">    b[i] = a[i];</div><div class="line">&#125;</div><div class="line">b.pop();</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//[1,2,3]</span></div></pre></td></tr></table></figure></p>
<p>很好，你会发现现在就算我们修改了新对象，原对象也并不会发生改动（浅复制），但如果你以为这样就成功了，那还有我们深拷贝什么事呢!</p>
<p>仔细看，你会发现我们的引用类型中的数据都是基本数据类型，那么换成引用类型又会发生什么呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;a.length;i++)&#123;</div><div class="line">    b[i] = a[i];</div><div class="line">&#125;</div><div class="line">b[<span class="number">0</span>].pop();</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//[[1,2],2,3]</span></div><div class="line">b.shift();</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//[[1,2],2,3]</span></div></pre></td></tr></table></figure></p>
<p>现在，你会无奈的发现，新建了对象后并没有什么卵用，其实还是引用类型在作怪，谁让它是通过栈内存中地址来指向的呢。</p>
<p>很明显，外层的修改并不会有什么问题，但是一旦涉及到引用类型，那么又会回到前面的老问题上面！</p>
<p>既然一层的复制不行，那么我们就用递归的方式对下面嵌套的所有引用类型一一进行浅复制，直到最后都转换为基本数据类型的拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//深拷贝函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> newObj = &#123;&#125;;</div><div class="line">    <span class="keyword">if</span>((<span class="keyword">typeof</span> obj) !== <span class="string">'object'</span>)&#123;</div><div class="line">        <span class="keyword">return</span> obj</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> obj)&#123;</div><div class="line">            newObj[attr] = <span class="built_in">arguments</span>.callee(obj[attr])</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newObj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">'liby'</span>,</div><div class="line">        <span class="attr">skills</span>:&#123;</div><div class="line">            <span class="attr">language</span>:<span class="string">'CET6'</span>,</div><div class="line">            <span class="attr">computer</span>:[<span class="string">'js'</span>,<span class="string">'python'</span>,<span class="string">'node'</span>],</div><div class="line">            <span class="attr">others</span>:[<span class="string">'skating'</span>]</div><div class="line">        &#125;    </div><div class="line">    &#125;</div><div class="line"><span class="keyword">var</span> b = deepClone(a);</div><div class="line">b.skills.others.push(<span class="string">'Balisong'</span>);</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//nothing changed</span></div></pre></td></tr></table></figure>
<p>现在，深拷贝完成，a和b已经不会再产生交集了，随便我们怎么折腾，哈哈！</p>
<h2 id="数组和对象原生方法实现深浅拷贝"><a href="#数组和对象原生方法实现深浅拷贝" class="headerlink" title="数组和对象原生方法实现深浅拷贝"></a>数组和对象原生方法实现深浅拷贝</h2><p>上面我们用自己写的方法递归实现了深复制，但是其实用对象提供的一些原生方法完全能够做到深浅拷贝，一起来记录一下吧！</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组有4种方法可以实现浅拷贝：concat（）和slice（），Array.from(),扩展运算符</p>
<h4 id="slice（）"><a href="#slice（）" class="headerlink" title="slice（）"></a>slice（）</h4><p>slice方法可用来在原数组上面分割形成新数组，第一个参数为0时，即切割全部，返回一个新数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line"><span class="keyword">var</span> newArr = arr.slice(<span class="number">0</span>)</div><div class="line">newArr[<span class="number">0</span>] = <span class="number">6</span></div><div class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<h4 id="concat（）"><a href="#concat（）" class="headerlink" title="concat（）"></a>concat（）</h4><p>concat方法用来合并两个数组，不传入参数则深拷贝此数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line"><span class="keyword">var</span> newArr = arr.concat();</div><div class="line">newArr[<span class="number">0</span>] = <span class="number">6</span>;</div><div class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1,2,3,4,5]</span></div></pre></td></tr></table></figure></p>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>这时ES6中的方法，用来将<strong>类数组</strong>转换为真正的数组，当然也可以用来深拷贝</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line"><span class="keyword">var</span> newArr = <span class="built_in">Array</span>.from(arr);</div><div class="line">newArr[<span class="number">0</span>] = <span class="number">6</span></div><div class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1,2,3,4,5]</span></div></pre></td></tr></table></figure>
<h4 id="…-扩展运算符"><a href="#…-扩展运算符" class="headerlink" title="…(扩展运算符)"></a>…(扩展运算符)</h4><p>同样也是ES6的东西，能够将一个数组轻易的<strong>解构</strong>并按照同样的模式赋值给新对象，其实内部是用的迭代器遍历复制，跟我们之前遍历复制很像，不过代码量少得多，哈哈，这也是浅拷贝！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line"><span class="keyword">var</span> newArr = [...arr];</div><div class="line">newArr[<span class="number">0</span>] = <span class="number">6</span></div><div class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//[1,2,3,4,5]</span></div></pre></td></tr></table></figure></p>
<h3 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h3><h4 id="object-assign-（浅拷贝）"><a href="#object-assign-（浅拷贝）" class="headerlink" title="object.assign()（浅拷贝）"></a>object.assign()（浅拷贝）</h4><p>object.assign()用来将任意uoge对象自身的<strong>可枚举属性</strong>拷贝给目标对象，不过<code>拷贝的只是对象的引用，而不是对象本身</code>，即浅拷贝。</p>
<h4 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h4><p>将元对象转成JSON字符串再转回来，最简单粗暴的一种深拷贝方法！！！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;<span class="string">'name'</span>:<span class="string">'liby'</span>,<span class="string">'course'</span>:&#123;<span class="string">'english'</span>:<span class="number">80</span>&#125;&#125;;</div><div class="line"><span class="keyword">var</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</div></pre></td></tr></table></figure></p>
<h4 id="jQuery-extend"><a href="#jQuery-extend" class="headerlink" title="jQuery.extend()"></a>jQuery.extend()</h4><p>jQuery.extend这个扩展对象的方法也可以用来进行深拷贝，需要传入true参数。</p>
<p>深浅拷贝的原理及方法已介绍完，如有遗漏，后续会补充上来！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/02/事件委托的优缺点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://og48zuyzv.bkt.clouddn.com/t01fad4ace94b4e1dd0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/02/事件委托的优缺点/" itemprop="url">
                  事件委托的优缺点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-02T23:26:30+08:00">
                2017-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面有篇博客已经大致介绍了JS的事件流机制，包含了捕获/冒泡/事件委托，接下来就委托的优缺点进行分析记录。</p>
<h2 id="事件委托（代理）出现背景"><a href="#事件委托（代理）出现背景" class="headerlink" title="事件委托（代理）出现背景"></a>事件委托（代理）出现背景</h2><p>一般情况下，我们如果想给元素绑定事件处理函数的话，都会采用DOM0级或者DOM2级提供的方法，如onclick或者addEventListener等。但是当我们在一个ul下面有很多个li元素，我们如果还用老方法一个个的进行绑定注册，这样不仅会增加我们的代码量,而且当我们要移除某个li元素时还得一个个地去解除元素和事件处理函数的绑定（关乎内存）,正是这些问题的出现，才有了基于<strong>冒泡机制</strong>的<code>事件委托</code>（代理）。</p>
<blockquote>
<p>在js中，当我们移除某个元素但没有将元素和监听函数进行解绑时，事件处理函数依旧会留在内存中，无法被当成垃圾回收。</p>
</blockquote>
<h2 id="优缺点总结"><a href="#优缺点总结" class="headerlink" title="优缺点总结"></a>优缺点总结</h2><p><strong>优点</strong>：</p>
<p>1.减少事件注册，节省内存，如：</p>
<ul>
<li>table可以代理所有td的click事件</li>
<li>ul代理所有li的click事件</li>
</ul>
<p>2.减少了dom节点更新的操作，处理逻辑只需在委托元素上进行，如：</p>
<ul>
<li>新添加的li不用绑定事件</li>
<li>删除li时，不需要进行元素与处理函数的解绑</li>
</ul>
<p><strong>缺点</strong>：</p>
<p>1.事件委托基于冒泡，对于onfoucs和onblur等事件不支持<br>2.层级过多，冒泡过程中，可能会被某层阻止掉（建议就近委托）</p>
<p>总之一切都是基于冒泡的，只要事件不支持冒泡或者中途有event.stopPropagation（）等，那么委托就会失败，所以并不适用于直接在document上进行委托。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/01/性能优化之重绘回流/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://og48zuyzv.bkt.clouddn.com/t01fad4ace94b4e1dd0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/01/性能优化之重绘回流/" itemprop="url">
                  性能优化之重绘回流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-01T20:03:20+08:00">
                2017-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇博客在介绍浏览器请求资源的过程中提及了<strong>重绘和回流</strong>，也对重绘回流的概念进行了介绍。根据概念，<code>至少会有一次回流和重绘发生在第一次页面加载时，且回流一定会导致重绘，重绘不一定引起回流</code>.</p>
<p>要进行性能优化，我们就必须搞清楚什么情况会导致回流和重绘，其中回流是重点，因为它的开销会比重绘高出很多。</p>
<h2 id="回流何时发生"><a href="#回流何时发生" class="headerlink" title="回流何时发生"></a>回流何时发生</h2><p>当页面布局和集合属性发生变化时就需要回流，常见的有以下情况：</p>
<ul>
<li>添加或者删除可见DOM元素</li>
<li>元素位置改变</li>
<li>元素尺寸改变</li>
<li>文本改变</li>
<li>图片（没有固定高度）加载src</li>
<li>页面初始化渲染</li>
<li>浏览器窗口尺寸改变（resize）</li>
<li>操作class属性</li>
<li>脚本操作DOM</li>
<li>计算offsetWidth和offsetHeight属性</li>
<li>设置style属性的值</li>
</ul>
<h2 id="浏览器队列"><a href="#浏览器队列" class="headerlink" title="浏览器队列"></a>浏览器队列</h2><p>当我们在js中操作dom的一些样式是，通常都会引起页面的重绘和回流，如果每次一引起回流重绘浏览器就重新去渲染的话，这样会耗费大量的时间。所以很多浏览器会维护1个队列，里面存放着回流和重绘的操作，等队列满了或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理，所有的重绘回流就变成了一次。</p>
<p>但有时我们的代码会引起浏览器提前flush队列，比如，当我们向浏览器请求以下style信息时，就会提前让浏览器flush队列：</p>
<ul>
<li>offsetTop,offsetLeft,offsetWidth,offsetHeight</li>
<li>scrollTop/Left/Width/Height</li>
<li>clientTop/Left/Width/Height</li>
<li>width,height</li>
<li>请求了getComputedStyle()或者IE的currentStyle</li>
</ul>
<blockquote>
<p>原因：<br>请求以上这些值时，浏览器需要清空队列，计算出最新的元素尺寸和位置样式信息（重绘回流），因为浏览器认为队列中的某些操作会造成我们获取的值并不是最精确的！</p>
</blockquote>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>在没有维护队列的浏览器中，减少重绘回流就需要我们<code>合并样式的修改</code>，尽量<code>一次渲染到位</code>，而有优化策略的浏览器，我们就要好好的利用这一点，<code>减少会提前flush队列的操作</code>。</p>
<p>1.将多个样式修改放到一个class中或者通过classText一次性修改：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//bad</span></div><div class="line"><span class="keyword">var</span> left = <span class="number">1</span>;</div><div class="line"><span class="keyword">var</span> top = <span class="number">1</span>;</div><div class="line">el.style.left = left + <span class="string">'px'</span>;</div><div class="line">el.style.top = top + <span class="string">'px'</span>;</div><div class="line"><span class="comment">//good</span></div><div class="line">el.className += <span class="string">'className1'</span>;</div><div class="line"><span class="comment">//good</span></div><div class="line">el.style.cssText += <span class="string">'left:'</span>+ left + <span class="string">'px;top:'</span> + top + <span class="string">'px;'</span></div></pre></td></tr></table></figure></p>
<p>2.避免访问会引起flush队列的属性，如要访问，利用缓存<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//bad</span></div><div class="line"><span class="keyword">for</span>()&#123;</div><div class="line">el.style.left = el.offsetLeft + <span class="number">5</span> + <span class="string">'px'</span>;</div><div class="line">el.style.top = el.offsetTop + <span class="number">5</span> + <span class="string">'px'</span>; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//good</span></div><div class="line"><span class="keyword">var</span> left = el.offsetLeft,top=el.offsetTop;</div><div class="line">s = el.style;</div><div class="line"><span class="keyword">for</span>()&#123;</div><div class="line">    left += <span class="number">10</span>;</div><div class="line">    top +=<span class="number">10</span>;</div><div class="line">    s.left = left + <span class="string">'px'</span>;</div><div class="line">    s.top = top + <span class="string">'px'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.动画效果应用到脱离文档流的元素上<br>元素脱离了文档流之后，不会影响其他元素的布局，所以只会导致重绘，可以减少开销</p>
<p>4.避免使用css表达式</p>
<p>5.让要操作的元素进行”离线处理”，处理完后一起更新</p>
<pre><code>a) 使用DocumentFragment进行缓存操作,引发一次回流和重绘；
b) 使用display:none技术，只引发两次回流和重绘；
c) 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/30/浏览器请求资源的过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://og48zuyzv.bkt.clouddn.com/t01fad4ace94b4e1dd0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/30/浏览器请求资源的过程/" itemprop="url">
                  浏览器请求资源的过程发生了什么
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-30T19:03:20+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>当我们在浏览器地址栏输入像’www.google.com’这样的网址时，按下Enter键后一段时间后就能看到网页呈现在我们面前，其实中间发生了很多事情，大致的流程是这样的：</p>
<ul>
<li>DNS域名解析</li>
<li>建立TCP连接（三次握手）</li>
<li>发起HTTP请求</li>
<li>获取响应结果</li>
<li>浏览器解析HTML，获取其他静态资源</li>
<li>浏览器页面渲染</li>
<li>断开链接（四次挥手）</li>
</ul>
<h2 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h2><p>DNS解析过程其实就是查询域名与IP映射的过程，在网络上，IP才是计算机的唯一（通讯）标识，之所以会出现域名，是因为它对于用户来说方便记忆并且有比IP更高的可用性。既然底层的通信是通过ip来进行的，那么我们输入url后，势必就需要一个中间人来帮我们进行<strong>域名</strong>到<strong>ip</strong>之间的转换，这样我们才可能进行后续的步骤，这个中间人就是DNS解析。</p>
<h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p>在分析解析过程之前，我们需要域名的组成方式：</p>
<table>
<thead>
<tr>
<th>组成部分</th>
<th>说明</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>根域</td>
<td>位于域名的末尾,用句号(.)表示,表明最高级别的层次结构</td>
<td>.</td>
</tr>
<tr>
<td>顶级域</td>
<td>用来指示某个国家/地区或组织使用的名称的类型名称</td>
<td>.com</td>
</tr>
<tr>
<td>二级域</td>
<td>个人或组织在Internet上使用的注册名称</td>
<td>google.com</td>
</tr>
<tr>
<td>子域</td>
<td>已注册的二级域名的派生域名，即网站名</td>
<td>www.google.com</td>
</tr>
</tbody>
</table>
<h4 id="域名服务器分类"><a href="#域名服务器分类" class="headerlink" title="域名服务器分类"></a>域名服务器分类</h4><p>这里有几种不同的域名服务器分类：</p>
<ul>
<li>根域名服务器：管理顶级域名，会告诉本地服务器顶级域名服务器的ip</li>
<li>顶级域名服务器：管理二级域名，与根服务器类似</li>
<li>权限域名服务器：负责一个区的域名服务器</li>
<li>本地域名服务器：主机发出的dns请求会先被发送到本地域名服务器</li>
</ul>
<h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>1 主机向本地域名服务器的查询一般都是<code>递归式查询</code>。递归查询：主机向本地服务器询问要查询域名对应的ip时，如果本地服务器不知道，便代替用户向根域名服务器发起请求。</p>
<p>2 本地域名服务器向根域名服务器的查询是<code>迭代查询</code>。迭代查询：当根服务器收到本地服务器的请求时，要么给出所要查询的ip地址，要么告诉本地服务器向下一级的域名服务器去查询。本地域名服务器再向顶级域名服务器发起请求，结果类似，查询不到的情况下继续向权限服务器发起请求，最终将结果返回给主机</p>
<p>综上所述：域名的解析过程类似下面：</p>
<blockquote>
<p><strong>.</strong>-&gt;<strong>.com</strong>-&gt;<strong>google.com</strong>-&gt;<strong>www.google.com</strong></p>
</blockquote>
<h5 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h5><p>现实生活中，淘宝双十一每分钟的请求量是无比巨大的，如果用户请求的都是同一台服务器的话，那么这对服务器的性能要求是非常之高的。但实际上，用户并不关心获取数据的来源，他们只关注更好的服务和更快更流畅的体验，这时我们就可以根据每台机器的负载量，该机器离用户地理位置的距离来给用户分配一个合适的服务器IP，这就叫做<code>DNS负载均衡</code>，又称<code>DNS重定向</code>，开发中经常涉及到的<code>CDN</code>就是利用了这个原理。</p>
<p>反向代理的原理和DNS负载均衡很像，都是为了解决负载均衡。</p>
<h2 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h2><p>由于HTTP是一个无状态要求可靠传输的协议，所以我们需要建立TCP而不是UDP链接。<br>TCP在建立链接的时候,需要经过三次握手：</p>
<ul>
<li>client先发送一个（SYN=1,seq=client_seq_num）标志的数据包给接收方</li>
<li>server接收后，回传一个（SYN=1,ack=client_seq+1,seq=server_seq_num）标志的数据包进行确认</li>
<li>client再回传一个（SYN=0,ack=server_seq+1）标志的数据包来表示握手成功</li>
</ul>
<blockquote>
<p>TCP对于由于各种问题而丢失的数据包会进行重传，这让用户能够接收到完整且正确的信息，这也是选用TCP而不是UDP的原因！</p>
</blockquote>
<h2 id="浏览器发送http请求"><a href="#浏览器发送http请求" class="headerlink" title="浏览器发送http请求"></a>浏览器发送http请求</h2><p>三次握手建立tcp连接完毕后，就是给服务器发送http请求了。<br>http请求报文包括三个部分：</p>
<ul>
<li>起始行</li>
<li>首部</li>
<li>主体</li>
</ul>
<h3 id="起始行"><a href="#起始行" class="headerlink" title="起始行"></a>起始行</h3><p>起始行中包括了请求方式,资源路径，http协议版本三部分<br>EXP： GET index.html HTTP/1.1</p>
<blockquote>
<p>常见的方法有：GET,POST,PUT,DELETE</p>
</blockquote>
<h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><p>首部在请求报文中又称请求报头，里面包含客户端自身的信息和向服务器发送的附加信息。</p>
<p>常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。<br>Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</p>
<h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>主体在请求报文中又称请求正文，对于GET方法来说他是空的，对于POST,PUT等方法来说，里面是要向服务器发送的数据，请求包头中有些字段与它有关，例如当主体中的数据格式为json时，这是要设置content-type为application/json。</p>
<h2 id="返回响应报文"><a href="#返回响应报文" class="headerlink" title="返回响应报文"></a>返回响应报文</h2><p>与请求报文类似，响应报文也由三部分组成：</p>
<ul>
<li>状态码</li>
<li>响应报头</li>
<li>响应正文</li>
</ul>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码都是3位的数字，百位上的数字代表了响应的类别，有5中可能的取值：</p>
<ul>
<li>1**：信息性状态码</li>
<li>2**：成功状态码<ul>
<li>200：OK 请求正常处理</li>
<li>204：No Content请求处理成功，但没有资源可返回</li>
<li>206：Partial Content对资源的某一部分的请求</li>
</ul>
</li>
<li>3**：重定向状态码<br>-301：Moved Permanently 永久重定向<br>-302：Found 临时性重定向<br>-304：Not Modified 缓存中读取</li>
<li>4**：客户端错误状态码<ul>
<li>400：Bad Request 请求报文中存在语法错误</li>
<li>401：Unauthorized需要有通过Http认证的认证信息</li>
<li>403：Forbidden访问被拒绝</li>
<li>404：Not Found无法找到请求资源</li>
</ul>
</li>
<li>5**：服务器错误状态码<ul>
<li>500：Internal Server Error 服务器端在执行时发生错误</li>
<li>503：Service Unavailable 服务器处于超负载或者正在进行停机维护</li>
</ul>
</li>
</ul>
<h3 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h3><p>常见字段：server，connection</p>
<h3 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h3><p>请求返回的文本信息（资源），如html，css，js，图片等文件就存放在里面。</p>
<h2 id="浏览器解析HTML，获取其他静态资源"><a href="#浏览器解析HTML，获取其他静态资源" class="headerlink" title="浏览器解析HTML，获取其他静态资源"></a>浏览器解析HTML，获取其他静态资源</h2><p>浏览器对于页面的解析时至上而下的，通过解析html来构建DOM树，当解析到&lt;link&gt;标签或@import时，就会请求服务器获取css文件，在下载的同时浏览器还是会继续向下解析的，但<strong>当下载js文件和执行它时，解析器便会停止手头的工作，等待js的操作完成后再向下解析</strong>，这便是js的阻塞问题，也是为什么&lt;link&gt;标签可以放在&lt;head&gt;中，而引入的js文件最好放在&lt;/body&gt;前面的原因，这样可以避免js阻塞了html的解析而导致页面短时间内无法呈现在用户面前的尴尬情况。</p>
<blockquote>
<p>html5中提供了defer和async来实现js外联的无阻塞加载</p>
</blockquote>
<p>&lt;link&gt;和@imoprt的区别：</p>
<ul>
<li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载</li>
<li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持</li>
<li>ink支持使用Javascript控制DOM去改变样式；而@import不支持</li>
</ul>
<h2 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h2><h3 id="渲染树（render树）"><a href="#渲染树（render树）" class="headerlink" title="渲染树（render树）"></a>渲染树（render树）</h3><p>前面已经说过，解析html的时候会生成<strong>DOM树</strong>，而解析css则会生成<strong>CSSOM树</strong>，前者描述内容，后者描述应用与内容的样式规则。</p>
<p>DOM树和CSSOM结合在一起会构成一棵渲染树，渲染树既包含了页面上所有的可视DOM节点，又包含了CSSOM中每个节点的样式信息。</p>
<p>渲染树的构建步骤：</p>
<ul>
<li><p>从DOM树的根节点开始，遍历所有的可视节点，不可视节点有：</p>
<ul>
<li>脚本标签，元数据标签</li>
<li>应用display：none的元素</li>
</ul>
</li>
<li><p>对于可视节点，从CSSOM中找到对应的样式规则，附加在节点上</p>
</li>
<li>输出可视节点以及每个节点计算出来的样式</li>
</ul>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>通过渲染树，浏览器已经能知道可视内容的样式信息了，但是真正要渲染时，我们还需要获取<strong>节点的位置和尺寸</strong>，这是布局阶段要做的工作，也成为<strong>“回流”（reflow）</strong>.</p>
<p>布局阶段的输出结果成为“盒模型”（box model），盒模型精确表达了窗口中元素的位置和大小，所有相对的度量单位都会被转化为屏幕上的绝对像素位置。</p>
<p>当以上步骤都完成后，浏览器就能把节点绘制成屏幕上每个真实的像素点了，此阶段为<strong>“绘制”或者“重绘”</strong>（resterizing）</p>
<p>其实从这里也能引出一个概念了：</p>
<blockquote>
<p><strong>回流必定导致重绘，重绘不一定导致回流</strong>^_^!</p>
</blockquote>
<p>页面渲染的过程中至少会发生一次reflow和repaint，reflow的开销相对与repaint要高得多。一般来说如果一个元素的尺寸发生了改变，会对后面的已渲染的页面造成影响，那么就需要重新计算布局，即回流，而如果只是改变了外观的话，那么只需要进行重绘即可。</p>
<p>举个通用的例子来说明一下重绘与回流：</p>
<ol>
<li>用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件；</li>
<li>浏览器开始载入html代码，发现&lt;head&gt;标签内有一个&lt;link&gt;标签引用外部CSS文件；</li>
<li>浏览器又发出CSS文件的请求，服务器返回这个CSS文件；</li>
<li>浏览器继续载入html中&lt;body&gt;部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了；</li>
<li>浏览器在代码中发现一个&lt;img&gt;标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</li>
<li>服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</li>
<li>浏览器发现了一个包含一行JavaScript代码的&lt;script&gt;标签，赶快运行它；</li>
<li>javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个&lt;div&gt; （style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；</li>
<li>终于等到了&lt;/html&gt;的到来，浏览器泪流满面……</li>
<li>等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下&lt;link&gt;标签的CSS路径；</li>
<li>浏览器召集了在座的各位&lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt;们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面</li>
</ol>
<p>对于重绘回流的优化以及js阻塞的解决会在另一篇博客提及。</p>
<h2 id="断开链接（四次挥手）"><a href="#断开链接（四次挥手）" class="headerlink" title="断开链接（四次挥手）"></a>断开链接（四次挥手）</h2><p>当浏览器获取到了所有想要的资源并且用户没有发起新的请求之前，为了不让tcp空耗着，我们会选择断开这个tcp链接，断开的主动方可以时服务器也可以是客户端。</p>
<p>假设有client发起终端请求，则过程是这样的：</p>
<ul>
<li>client端发起FIN报文，告诉server端如果数据没发送完，可以不急着关闭socket，继续发送</li>
<li>server端收到FIN报文后，回传一个确认包并让client等待（因为自己要确认是否已经发送完数据了），client进入<strong>FIN_WAIT</strong>状态</li>
<li>server确认自己已经发送完所有数据了，可以真正关闭链接了，向client发送FIN</li>
<li>client收到FIN后回传一个ACK并进入<strong>TIME_WAIT</strong>状态</li>
<li>server接收到ACK后关闭链接</li>
<li>client在2MSL（<strong>报文最大生存时间</strong>，4分钟）后如果没有收到server发过来的FIN包，证明server端已经关闭成功，那么自己也可以关闭了</li>
</ul>
<p>需要四次挥手的原因：</p>
<blockquote>
<p>当一方主动发起FIN请求是，可能另一方的数据还没发送完，故此只能返回一个ACK让他先等待，只有当自己确认已经发送完所有的数据后才会发起一个FIN来并当接收到一个回传的ACK时结束这个连接，俗称四次挥手。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/21/canvas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://og48zuyzv.bkt.clouddn.com/t01fad4ace94b4e1dd0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/21/canvas/" itemprop="url">
                  H5之canvas标签（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-21T18:25:25+08:00">
                2017-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HTML5中添加了很多新的标签，canvas就是其中之一，它被用来进行图形的绘制，关于图形的绘制我们需要通过javascript来完成，canvas标签仅是一个图形的容器。</p>
<p>IE9及其他现代浏览器基本都支持这个标签。</p>
<p>canvas由几组API组成，除了绘制基本图形的2D上下文，还有一个名为WebGL的3D上下文，不过浏览器支持还不够好，</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>使用\<canvas\>时，我们需要设置其宽高，用来指定绘图的区域。出现在开始和结束标签之间的内容作为后备信息，当浏览器不支持该标签时，里面的内容就会显示出来，HTML5中其他标签也是这么干的。<br>一个简单的canvas实例如下:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">"299"</span> <span class="attr">height</span>=<span class="string">"199"</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span>&gt;</span>sorry,the canvas isn't supported.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div></pre></td></tr></table></figure></canvas\></p>
<p>这是我们的画布，也是我们绘制的图像的一个载体，要在画布上绘图，我们需要先通过<strong>getContext()</strong>方法取得绘图上下文：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</div><div class="line"><span class="comment">//检测浏览器是否支持canvas</span></div><div class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</div><div class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用toDataUrl（）方法可以导出在canvas上绘制的图像。该方法接受一个MIME类型参数，如果我们需要取得画布中的一幅png图像，可以这样做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</div><div class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</div><div class="line">    <span class="keyword">var</span> imageUrl = drawing.toDataUrl(<span class="string">"image/png"</span>);</div><div class="line">    <span class="comment">//显示图像</span></div><div class="line">    <span class="keyword">var</span> image = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</div><div class="line">    image.src = imageUrl;</div><div class="line">    <span class="built_in">document</span>.body.append(image);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>默认情况下，MIME类型为PNG格式。</p>
<h3 id="canvas坐标系"><a href="#canvas坐标系" class="headerlink" title="canvas坐标系"></a>canvas坐标系</h3><p>canvas以左上角为原点（0,0），坐标值都以原点为参照进行计算，与background背景图片的位置计算方法相同。第一个值代表离左边框的距离，第二个值代表离上边框的距离。</p>
<h3 id="填充和描边"><a href="#填充和描边" class="headerlink" title="填充和描边"></a>填充和描边</h3><p>通过2D绘图上下文提供的方法，我们可以绘制矩形，弧线等2D图形。对于这些图形，我们可以选择绘制的方式。这里有两个属性，来决定是进行填充还是进行描边：fillStyle和strokeStyle</p>
<p>这两个属性的值可以是字符串、渐变对象、或模式对象，默认值都是“#000000”。我们可以用任何的颜色格式（rgb、rgba、hsl、hsla）来定义样式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</div><div class="line"><span class="comment">//检测浏览器是否支持canvas</span></div><div class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</div><div class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</div><div class="line">    context.strokeStyle = <span class="string">"green"</span>;</div><div class="line">    context.fillStyle = <span class="string">"#f6c"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样设置后，下面涉及到填充和描边的操作都会使用这两个样式，绘制过程中样式可更改。</p>
<h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p>与绘制矩形相关的方法有：fillRect（）、strokeRect（）、clearRect（），这些参数都接受4个参数：矩形x坐标、矩形y坐标、矩形宽度、矩形高度，单位都为像素。</p>
<p>绘制图形前都应先指定填充或者描边的样式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</div><div class="line"><span class="comment">//检测浏览器是否支持canvas</span></div><div class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</div><div class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</div><div class="line">    </div><div class="line">    context.strokeStyle = <span class="string">"green"</span>;</div><div class="line">    context.strokeRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">50</span>);</div><div class="line">    </div><div class="line">    context.fillStyle = <span class="string">"rgba(0,0,0,0.6)"</span>;</div><div class="line">    context.fillRect(<span class="number">100</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此外，还有以下属性能够控制线条和线条末端的形状：</p>
<ul>
<li>lineWidth：线条宽度</li>
<li>lineCap：用于控制线条末端的形状，取值有butt（平头），round（圆头),square（方头）</li>
<li>lineJoin：控制线条相交的方式，取值有round（圆交），bevel（斜交），miter（斜接）</li>
</ul>
<h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><p>2D绘图上下文提供了很多用于绘制路径的方法。在绘制之前，需要先调用beginPath（），表示要开始绘制新路径。然后再调用下面的方法绘制实际路径。</p>
<h4 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h4><p>arc（x,y,radius,startAngle,endAngle,conterclockwise）:以（x,y）为圆心，radius为半径，起始和结束弧度分别为startAngle，endAngle来画圆弧，counterclockwise为false代表按逆时针计算角度。</p>
<p>我们用这个方法来绘制一个圆形：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var drawing = document.getElementById("myCanvas");</div><div class="line">//检测浏览器是否支持canvas</div><div class="line">if(drawing.getContext)&#123;</div><div class="line">    var context = drawing.getContext("2d");</div><div class="line">    context.beginPath();</div><div class="line">    context.arc(100,100,40,0,Math.PI*2,true)'</div><div class="line">    //注意，这里不关闭路径的话会从上个路径继续绘制下个图形</div><div class="line">    context.closePath();</div><div class="line">    context.fillStyle = 'rgba(0,0,0,0.6)';</div><div class="line">    context.fill();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://og48zuyzv.bkt.clouddn.com/canvas1/canvas1.png" alt="canvas1"></p>
<blockquote>
<p>绘制完一个图形要关闭路径，并且最后需要调用fill（）和stroke（）才能将图形绘制到画布上。</p>
</blockquote>
<p>画圆弧还有另外一个方法，<strong>arcTo（x1,y1,x2,y2,radius）</strong>：传入弧起点和终点的坐标以及弧的半径。</p>
<h4 id="moveTo（）和lineTo（）"><a href="#moveTo（）和lineTo（）" class="headerlink" title="moveTo（）和lineTo（）"></a>moveTo（）和lineTo（）</h4><ul>
<li>moveTo(x,y)：将绘图游标移动到（x,y），不画线</li>
<li>lineTo（x,y）：在上一点和（x,y）之间绘制一条直线</li>
</ul>
<p>注意：</p>
<p>每次画线都是从moveTo的点到lineTo的点</p>
<p>如果没有moveTo，第一次lineTo的效果和moveTo相同</p>
<p>每次lineTo后如果没有moveTo，下次会从上次lineTo的终点开始画线</p>
<p>结合上面和圆弧来写一个时钟表盘的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</div><div class="line"><span class="comment">//检测浏览器是否支持canvas</span></div><div class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</div><div class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</div><div class="line">    context.beginPath();</div><div class="line">    <span class="comment">//绘制外圆   </span></div><div class="line">    context.arc(<span class="number">100</span>,<span class="number">100</span>,<span class="number">80</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">false</span>);</div><div class="line">    <span class="comment">//绘制内圆</span></div><div class="line">    context.arc(<span class="number">100</span>,<span class="number">100</span>,<span class="number">75</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">false</span>);</div><div class="line">    <span class="comment">//绘制分针</span></div><div class="line">    context.moveTo(<span class="number">100</span>,<span class="number">100</span>);</div><div class="line">    context.lineTo(<span class="number">100</span>,<span class="number">35</span>);</div><div class="line">    <span class="comment">//绘制时针</span></div><div class="line">    context.moveTo(<span class="number">100</span>,<span class="number">100</span>);</div><div class="line">    context.lineTo(<span class="number">47</span>,<span class="number">100</span>);</div><div class="line">    <span class="comment">//描边</span></div><div class="line">    context.stroke();</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果：</p>
<p><img src="http://og48zuyzv.bkt.clouddn.com/canvas1/canvas2.png" alt="cavas2"></p>
<h4 id="贝塞尔曲线（bezier）"><a href="#贝塞尔曲线（bezier）" class="headerlink" title="贝塞尔曲线（bezier）"></a>贝塞尔曲线（bezier）</h4><p>我们可以通过bezierCurveTo（）方法来画贝塞尔曲线，该方法有6个参数：clx，cly，c2x，c2y，x，y。该方法会从上一点到（x，y）之间绘制一条曲线，并以（c1x,c1y）和(c2x,c2y)为控制点。</p>
<p>还有一个跟这个方法类似的方法–quadraticCurveTo（c1x,c2y,x,y）,用法相同，区别在于只有一个控制点（c1x,c1y），这是一个二次曲线的绘制方法。</p>
<p>如下例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</div><div class="line"><span class="comment">//检测浏览器是否支持canvas</span></div><div class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</div><div class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</div><div class="line">    context.beginPath();</div><div class="line">    context.moveTo(<span class="number">50</span>,<span class="number">50</span>);</div><div class="line">    context.bezierCurveTo(<span class="number">50</span>, <span class="number">50</span>,<span class="number">150</span>, <span class="number">50</span>, <span class="number">150</span>, <span class="number">100</span>);</div><div class="line">	context.quadraticCurveTo(<span class="number">150</span>, <span class="number">150</span>, <span class="number">250</span>, <span class="number">200</span>);</div><div class="line">	context.stroke();</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果：</p>
<p><img src="http://og48zuyzv.bkt.clouddn.com/canvas1/canvas3.png" alt="canvas3"></p>
<h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><p>绘制文本主要有两个方法：fillText（）和strokeText（）。这两个方法都接收4个参数：要绘制的字符串，x坐标，y坐标，最大像素宽度。</p>
<p>同时，这两个方法都以下面3个属性为基础：</p>
<ul>
<li>font：表示文本样式、大小和字体，如”bold 14px Arial“</li>
<li>textAlign：表示文本对齐方式，取值有start、end、left、right、center。建议使用start和end，而不是left、right</li>
<li>textBaseline：表示文本的基线（垂直对齐方式），取值有top、hanging、middle、alphabetic、ideographic、bottom</li>
</ul>
<p>这几个属性值都有默认值，fillText（）会使用fillStyle来填充文字，strokeText（）则使用strokeStyle为文字描边。</p>
<p>绘制文本比较复杂，特别是但我们需要将文本控制在某个区域中时，为此，2d上下文为我们提供了一个确定文本你大小的方法measureText（），返回的是个包含width属性的对象。</p>
<p>现在，如果我们想在一个150px宽度的矩形中绘制“hello canvas！”，我们可以这样做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fontSize = <span class="number">30</span>；</div><div class="line">context.font = fontSize+<span class="string">"px Arial"</span>;</div><div class="line"><span class="keyword">while</span>(context.measureText(<span class="string">"hello canvas!"</span>)&gt;<span class="number">150</span>)&#123;</div><div class="line">    fontSize--;</div><div class="line">    context.font = fontSize + <span class="string">"px Arial"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">context.fillText(<span class="string">"hello canvas!"</span>,<span class="number">10</span>,<span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<p>上面代码会从30像素开始递减，直到文本的宽度小于150px，即找到合适的字体大小。</p>
<h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><p>canvas中的渐变我们通过canvasGradient实例来实现，生成渐变对象的方法有两个：</p>
<ul>
<li>createLinearGradient（x1,y1,x2,y2）：接收渐变的起点（x1,y1）和终点和（x2,y2）</li>
<li>createRadialGradient(x1,y1,r1,x2,y2,r2):跟上面方法类似，前三个参数定义一个以（x1,y1）为圆心，r1为半径的圆，后三个参数定义一个以（x2,y2）为圆心，r2为半径的圆</li>
</ul>
<p>通过上述方法创建好实例后，需要用addColorStop方法来上色，<br>addColorStop（）有两个参数：色标位置以及css颜色值，色标位置介于0到1之间。</p>
<p>可以根据需要添加多个色标。</p>
<p>来看2个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</div><div class="line"><span class="comment">//检测浏览器是否支持canvas</span></div><div class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</div><div class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</div><div class="line">    <span class="comment">//创建一个线性渐变实例</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> gradient = context.createLinearGradient(<span class="number">50</span>,<span class="number">50</span>,<span class="number">150</span>,<span class="number">150</span>);</div><div class="line">    gradient.addColorStop(<span class="number">0</span>,<span class="string">'#33cccc'</span>);</div><div class="line">    gradient.addColorStop(<span class="number">1</span>,<span class="string">'#ffccff'</span>);</div><div class="line">        </div><div class="line">    context.fillStyle = gradient;</div><div class="line">    context.fillRect(<span class="number">50</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">100</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//创建径向渐变实例</span></div><div class="line">    <span class="keyword">var</span> radial = context.createRadialGradient(<span class="number">250</span>,<span class="number">100</span>,<span class="number">20</span>,<span class="number">300</span>,<span class="number">150</span>,<span class="number">50</span>);</div><div class="line">    radial.addColorStop(<span class="number">0</span>,<span class="string">'white'</span>);</div><div class="line">    radial.addColorStop(<span class="number">1</span>****,<span class="string">'black'</span>);</div><div class="line">    context.fillRect(<span class="number">200</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">100</span>);   </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果：</p>
<p><img src="http://og48zuyzv.bkt.clouddn.com/canvas1/canvas6.png" alt="canvas6"></p>
<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>2D上下文提供了几个绘制阴影的属性，这些属性会自动为图形或者路径添加阴影。</p>
<ul>
<li>shadowColor：css颜色值形式的阴影颜色</li>
<li>shadowOffsetX：沿x轴的偏移量</li>
<li>shadowOffsetY：沿y轴的偏移量</li>
<li>shadowBlur：模糊的像素数，默认为0</li>
</ul>
<p>看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</div><div class="line"><span class="comment">//检测浏览器是否支持canvas</span></div><div class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</div><div class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</div><div class="line">    <span class="comment">//创建一个线性渐变实例</span></div><div class="line">    </div><div class="line">    context.shadowOffsetX = <span class="number">5</span>;</div><div class="line">    context.shadowOffsetY = <span class="number">4</span>;</div><div class="line">    context.shadowBlur = <span class="number">5</span>;</div><div class="line">    context.shadowColor = <span class="string">'#cff8de'</span>;</div><div class="line">    </div><div class="line">    context.fillStyle=<span class="string">"#3399ff"</span>;</div><div class="line">    context.fillRect(<span class="number">40</span>,<span class="number">40</span>,<span class="number">100</span>,<span class="number">100</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>效果：</p>
<p><img src="http://og48zuyzv.bkt.clouddn.com/canvas1/canvas7.png" alt="canvas7"></p>
<h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><p>2D绘制上下文支持我们对图像进行绘制变换，变换时我们需要用到变换矩阵，下面的方法会改变变换矩阵，从而导致不同的效果。</p>
<h4 id="save（）和restore（）"><a href="#save（）和restore（）" class="headerlink" title="save（）和restore（）"></a>save（）和restore（）</h4><p>了解变形之前需要先知道两个在绘制图形时必不可少的方法–save（）和restore（），他们是用来保存和回复canvas状态的，不需要传入参数。</p>
<p>canvas状态存储在栈中，当save（）方法被调用时，当前的状态就会被保存到栈中。</p>
<p>canvas状态包括的内容有：</p>
<ul>
<li>当前应用的变形（scale，translate，rotate）</li>
<li>strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值</li>
<li>当前的裁剪路径（clipping path）</li>
</ul>
<p>而restore（）方法被调用时，则会从栈中弹出上一个保存的状态，恢复所有设定。</p>
<h4 id="translate（）"><a href="#translate（）" class="headerlink" title="translate（）"></a>translate（）</h4><p>translate（x,y）方法接收新位置的坐标，x是左右偏移量，y是上下偏移量，<strong>表示将坐标原点</strong>移到（x,y）。</p>
<blockquote>
<p>这里需要牢记偏移的是坐标原点，实际上所有变形操作的都是坐标原点。</p>
</blockquote>
<p>在变形之前用save（）保存状态是一个好的习惯，因为在一个循环中做位移但没有保存和回复canvas状态，最后有些东西会不见，因为它很可能超出了canvas范围之外了。</p>
<h4 id="rotate（）"><a href="#rotate（）" class="headerlink" title="rotate（）"></a>rotate（）</h4><p>rotate（）方法接收一个angle参数，通过这个方法我们可以围绕原点旋转图像。</p>
<p>通过旋转，我们可以绘制有趣的图形：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</div><div class="line"><span class="comment">//检测浏览器是否支持canvas</span></div><div class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</div><div class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</div><div class="line">    context.translate(<span class="number">100</span>,<span class="number">100</span>);</div><div class="line">    context.translate(<span class="number">100</span>,<span class="number">100</span>);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</div><div class="line">        context.save();</div><div class="line">        context.fillStyle=<span class="string">'rgb('</span>+(<span class="number">51</span>*i)+<span class="string">',255,'</span>+(<span class="number">255</span><span class="number">-51</span>*i)+<span class="string">')'</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;i*<span class="number">6</span>;j++)&#123;</div><div class="line">            context.rotate(<span class="built_in">Math</span>.PI*<span class="number">2</span>/(i*<span class="number">6</span>));</div><div class="line">            context.beginPath();</div><div class="line">            context.arc(<span class="number">0</span>,i*<span class="number">12.5</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="built_in">Math</span>.PI*<span class="number">2</span>,<span class="literal">true</span>);</div><div class="line">            context.fill();</div><div class="line">        &#125;</div><div class="line">        context.restore();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://og48zuyzv.bkt.clouddn.com/canvas1/canvas4.png" alt="canvas4"></p>
<h4 id="scale（）"><a href="#scale（）" class="headerlink" title="scale（）"></a>scale（）</h4><p>变形的另外一个方法是scale（x,y），即缩放。它接收两个参数，分别为x轴和y轴的缩放因子，默认都是1.</p>
<h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><p>变形的最后一个方法是transform（m11,m12,m21,m22,dx,dy）,这个方法会讲当前的变形矩阵乘上一个基于自身参数的矩阵，各个参数的意义如下：</p>
<ul>
<li>m11：水平方向的缩放</li>
<li>m12：水平方向的偏移</li>
<li>m21：垂直方向的偏移</li>
<li>m22：垂直方向的缩放</li>
<li>dx：水平方向的移动</li>
<li>dy：垂直方向的移动</li>
</ul>
<p>setTransform（m11,m12,m21,m22,dx,dy）会将变化矩阵重置为单位矩阵然后再调用transform（）。</p>
<p>resetTransform（m11,m12,m21,m22,dx,dy）将当前变形为单位矩阵。</p>
<p>tranlate（）、scale（）、rotate（）三个方法调用的先后顺序不同，最后出现的效果也不同，但是只要记住这三个方法都是操作的坐标轴，就会好理解得多了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</div><div class="line"><span class="comment">//检测浏览器是否支持canvas</span></div><div class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</div><div class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>);</div><div class="line">    context.save(); <span class="comment">//保存了当前context的状态</span></div><div class="line">    context.fillStyle = <span class="string">"#EEEEFF"</span>;</div><div class="line">    context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</div><div class="line"></div><div class="line">    context.fillStyle = <span class="string">"red"</span>;</div><div class="line">	<span class="comment">//平移 缩放 旋转   </span></div><div class="line">    context.translate(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    context.scale(<span class="number">0.5</span>, <span class="number">0.5</span>);</div><div class="line">    context.rotate(<span class="built_in">Math</span>.PI / <span class="number">4</span>);</div><div class="line">    context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line"></div><div class="line">	context.restore(); <span class="comment">//恢复到刚刚保存的状态</span></div><div class="line">	context.save(); <span class="comment">//保存了当前context的状态</span></div><div class="line">	context.fillStyle = <span class="string">"green"</span>;</div><div class="line">	<span class="comment">//缩放 平移 旋转 2 1 3 </span></div><div class="line">	context.scale(<span class="number">0.5</span>, <span class="number">0.5</span>);</div><div class="line">	context.translate(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">	context.rotate(<span class="built_in">Math</span>.PI / <span class="number">4</span>);</div><div class="line">	context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line"></div><div class="line">	context.restore(); <span class="comment">//恢复到刚刚保存的状态</span></div><div class="line">	context.save(); <span class="comment">//保存了当前context的状态</span></div><div class="line">	context.fillStyle = <span class="string">"blue"</span>;</div><div class="line">	<span class="comment">//缩放 旋转 平移  2 3  1 </span></div><div class="line">	context.scale(<span class="number">0.5</span>, <span class="number">0.5</span>);</div><div class="line">	context.rotate(<span class="built_in">Math</span>.PI / <span class="number">4</span>);</div><div class="line">	context.translate(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">	context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line"></div><div class="line">	context.restore(); <span class="comment">//恢复到刚刚保存的状态</span></div><div class="line">	context.save(); <span class="comment">//保存了当前context的状态</span></div><div class="line">	context.fillStyle = <span class="string">"pink"</span>;</div><div class="line">	<span class="comment">//旋转 平移 缩放  3 1 2 </span></div><div class="line">	context.rotate(<span class="built_in">Math</span>.PI / <span class="number">4</span>);</div><div class="line">	context.translate(<span class="number">100</span>, <span class="number">100</span>);</div><div class="line">	context.scale(<span class="number">0.5</span>, <span class="number">0.5</span>);</div><div class="line">	context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://og48zuyzv.bkt.clouddn.com/canvas1/canvas5.png" alt="canvas5"></p>
<blockquote>
<p>（平移，缩放，旋转）和（平移，旋转，缩放）效果一样，（缩放，旋转，平移）和（旋转，缩放，平移）一样</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/20/js-event2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://og48zuyzv.bkt.clouddn.com/t01fad4ace94b4e1dd0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/20/js-event2/" itemprop="url">
                  JS之事件（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-20T18:26:16+08:00">
                2017-06-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="键盘与文本事件"><a href="#键盘与文本事件" class="headerlink" title="键盘与文本事件"></a>键盘与文本事件</h2><p>对键盘事件的支持主要遵循的是DOM0级，DOM3中制定了新的规范。</p>
<p>键盘事件有三个：</p>
<ul>
<li>keydown：按下任意键时触发，按住不放会重复触发</li>
<li>keypress：用户按下键盘上的<strong>字符键</strong>时触发，按住不放会重复触发</li>
<li>keyup：用户释放按键时触发</li>
</ul>
<blockquote>
<p>虽然所有元素都支持这些事件，但一般在文本框输入时才会用到。</p>
</blockquote>
<p>文本事件只有一个：textInput，此事件是对keypress的补充，在文本出入文本框之前会触发这事件</p>
<p>按下字符键时，键盘事件的触发顺序如下：</p>
<ol><br>    <li>keydown事件</li><br>    <li>keypress事件</li><br>    <li>keyup事件</li><br></ol>

<p>keydown和keypress都是文本框内容发生变化前触发，而keyup则是文本框发生变化后触发的。</p>
<p>如果用户按下的是字符键，那么会先触发keydown事件，然后就是keyup事件。</p>
<blockquote>
<p>键盘事件也支持相同的修改键，所以键盘事件的事件对象中也有shiftKey、ctrlKey、altKey和metaKey属性。</p>
</blockquote>
<h3 id="键码"><a href="#键码" class="headerlink" title="键码"></a>键码</h3><p>在发生keydown和keyup事件时，event对象的keyCode属性中会包含一个键码，该键码的值与数字字母字符键对应的ASCII码相同，如A对应的keyCode值就是65，详细的对应表大家可以百度。</p>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><p>IE9+及现代浏览器（除Opera）都支持一个charCode属性，只有在发生keyPress事件时才会包含此属性，值为字符键所对对应的ASCII码或者为0（非字符键）。IE8之前版本和Opera并不支持这个属性，所以我们需要实现跨浏览器的方式来获取字符编码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> eventUtil = &#123;</div><div class="line">    <span class="string">'getCharCode'</span>:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> event.charCode == <span class="string">"number"</span>)&#123;</div><div class="line">            <span class="keyword">return</span> event.charCode;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> event.keyCode;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取得字符编码后，就可以用fromCharCode（）将其转化为实际的字符。</p>
<h3 id="DOM3级键盘事件"><a href="#DOM3级键盘事件" class="headerlink" title="DOM3级键盘事件"></a>DOM3级键盘事件</h3><p>DOM3级事件中作出了一些修改：</p>
<ul>
<li>key:用来取代keyCode，值是一个字符串，在按下字符键时，值是对应的文本字符（区分大小写），按下非字符键时，值是对应键名（如“shift”）</li>
<li>char：取代charCode，与key类似，不过按下非字符键时，值为null</li>
</ul>
<blockquote>
<p>IE9支持key但不支持char属性。Safari 5 和Chrome支持KeyIdentifier的属性，于key属性类似，不过当按下字符键时，keyIdentifier的值是一个Unicode值，不再是ASCII码。由于存在跨浏览器的兼容问题，不推荐使用key，char，和keyIdentifier。</p>
</blockquote>
<h2 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h2><p>DOM规范并没有包含所有浏览器支持的所有事件，很多浏览器都实现了自定义的事件，为此，html5列出了浏览器应该支持的所有事件。</p>
<h3 id="contextmenu事件"><a href="#contextmenu事件" class="headerlink" title="contextmenu事件"></a>contextmenu事件</h3><p>网页中，我们通过右键可以调出上下文菜单，有时我们需要屏蔽这个默认事件，转而使用我们自定义的菜单，这时就需要使用contextmenu事件。此事件是冒泡的，所以我们可以为document指定一个事件处理程序，用以处理页面中触发的所有此类事件。</p>
<p>实际应用中，我们需要结合事件对象的<strong>clientX和clietY</strong>来定位菜单出现的位置，同时当用户点击菜单时应该隐藏菜单。</p>
<h3 id="beforeunload事件"><a href="#beforeunload事件" class="headerlink" title="beforeunload事件"></a>beforeunload事件</h3><p>beforeunload让我们有可能在页面卸载前阻止这一操作，继续使用原有页面。但是我们不能让用户无法离开当前页面，而是应该将决定权交给用户，只是在离开前提示一些信息，询问用户是否真的要离开。</p>
<p>如果要在用户关闭时弹出一个信息框，需要这样做：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">EventUtil.addEventHander(<span class="built_in">window</span>,<span class="string">"beforeunload"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    event = eventUtil.getEvent(event);</div><div class="line">    <span class="keyword">var</span> message = <span class="string">'你真的要离开此页面吗？'</span></div><div class="line">    event.returnValue = message;<span class="comment">//IE及FF做法</span></div><div class="line">    <span class="keyword">return</span> message;<span class="comment">//safari及Chrome做法</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="pageshow事件和pagehide事件"><a href="#pageshow事件和pagehide事件" class="headerlink" title="pageshow事件和pagehide事件"></a>pageshow事件和pagehide事件</h3><p>在FF和Opera中有一个特性，<strong>往返缓存（back-foward cache 或bfcache）</strong>，能够使用户在后退或者前进时加快页面加载速度，其实他们是把整个网页保存在了缓存中。但是这里会有一个问题，如果我们的网页在bfcache中，那么再次打开着页面是不会触发load事件的，这对于那些需要在页面加载完执行一些事件的页面来说，就有可能会造成页面显示不正确。</p>
<p>而pageshow事件在页面显示时会触发，无论该页面是不是存在于bfcache中。虽然事件的目标是document，但是必须要将其监听程序绑定在window上。</p>
<p>pageshow事件对象还包含一个<strong>persisted</strong>属性，如果值为true，则表示页面存放在bfcache中。</p>
<p>pagehide事件会在unload事件之前触发，如果页面在卸载之后是存放在bfcache中，那么persisted值为true。</p>
<blockquote>
<p>IE9+及现代浏览器都支持这两个事件。</p>
</blockquote>
<h3 id="触摸与手势事件"><a href="#触摸与手势事件" class="headerlink" title="触摸与手势事件"></a>触摸与手势事件</h3><p>现如今，移动端已然成为了除PC端外另一个网络流量的汇聚地，其中ios和Adroid最为耀眼，但是这些设备没有鼠标也没有键盘，那么我们要怎么监听用户的操作呢？移动端其实主要还是通过用户的手指触摸（touch）来触发事件，为此，html5提供了touch系列的事件来实现我们的目的。</p>
<ul>
<li>touchstart：当手指触摸屏幕时触发，即时已经有手指放在屏幕上也会触发</li>
<li>touchmove：当手指在屏幕滑动时连续触发</li>
<li>touchend：手指从屏幕移开时触发</li>
<li>touchcancel：系统停止跟踪触摸是触发</li>
</ul>
<p>这些事件都是会冒泡，且event对象中也都包含常见的属性：clientX，clientY，bubbles，cancelable，detial，screenX，screenY等</p>
<p>除此之外，触摸事件还支持三个用于跟踪触摸的属性：</p>
<ul>
<li>touches：表示当前跟踪的触摸操作的touch对象的数组</li>
<li>targetTouchs：特定于事件目标的touch对象的数组</li>
<li>changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组</li>
</ul>
<p>触摸事件和鼠标事件的触发顺序如下：</p>
<ol><br>    <li>touchstart</li><br>    <li>mouseover</li><br>    <li>mousemove</li><br>    <li>mousedown</li><br>    <li>mouseup</li><br>    <li>click</li><br>    <li>touchend</li><br></ol>

<p>关于js事件较常用的都已经介绍完了，如果想更加详尽的学习，可以看javascript高级程序设计这本书，后面可能会通过一些例子或者项目将这些知识结合起来，敬请期待！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/19/js之鼠标和键盘事件一/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Liby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://og48zuyzv.bkt.clouddn.com/t01fad4ace94b4e1dd0.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Liby">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/19/js之鼠标和键盘事件一/" itemprop="url">
                  JS之事件（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-19T22:21:16+08:00">
                2017-06-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>事件，像click，load，mouseover都是用户或者浏览器执行的某种动作,都会触发某些事件。在触发事件的时候，我们需要有一个事件监听函数（事件处理程序）来响应事件。事件监听函数的名字都是<strong>“on”</strong>+<strong>事件名</strong>组成的，像click的事件监听函数就是onclick。</p>
<h2 id="HTML事件监听程序"><a href="#HTML事件监听程序" class="headerlink" title="HTML事件监听程序"></a>HTML事件监听程序</h2><p>对于元素支持的每种事件，都可以在元素中指定一个与事件监听函数同名的特性。特性的值是要执行的js代码，比如下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"clicked me"</span> <span class="attr">onclick</span>=<span class="string">"console.log('clicked')"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>如果函数体内容多的话，需要把js代码放到javascript标签内，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMessage</span>（）</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log（‘clicked’）；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"clicked me"</span> <span class="attr">onclick</span>=<span class="string">"showMessage（）"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>但是这样指定事件监听函数让得HTML与Javascript紧密耦合，如果需要更换事件监听函数，那么HTML和javascripot代码都需要修改，所以为什么不干脆全部使用js来绑定和声明事件监听函数呢！</p>
<h2 id="js事件监听程序"><a href="#js事件监听程序" class="headerlink" title="js事件监听程序"></a>js事件监听程序</h2><h3 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h3><p>每个元素都有自己的事件处理程序属性，通常事件名都为小写，如：onclick，onmouseover，在绑定处理函数时需要先获得元素的引用，直接看一个简单的例子吧：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = doucment.getElementById(<span class="string">'button1'</span>);</div><div class="line"></div><div class="line">btn.onclick  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);<span class="comment">//button1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>程序中的this指向的是当前元素，即btn，通过点取的方式，我们可以访问元素的任何属性和方法。</p>
</blockquote>
<h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><p>“DOM2级事件”定义了两个用于绑定事件和移除事件的方法：addEventListener（）和removeEevntListener（），这两个方法在之前冒泡和捕获那一节已经介绍过了，就不过多说明了。</p>
<p>这两个方法都接收三个参数：</p>
<ul>
<li>事件名（不带on）</li>
<li>事件处理函数</li>
<li>是否捕获</li>
</ul>
<p>addEventListener（）的优势在于可以为同一元素绑定多个方法，执行顺序由绑定先后决定。</p>
<blockquote>
<p>在移除时传入的参数要与绑定时相同，这也意味着不能移除匿名函数</p>
</blockquote>
<h3 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h3><p>IE实现两个类似的方法：attachEvent（）和detachEvent（），之前同样也介绍过，下面就说一下特别的地方。</p>
<p>这两个方法都接收两个参数：</p>
<ul>
<li>事件名</li>
<li>事件处理函数</li>
</ul>
<blockquote>
<p>DOM0级方法中事件处理程序会在元素的作用域内进行，而使用这两个方法时程序会在全局作用域中运行，因为this指向window。</p>
</blockquote>
<p>和addEventListener（）类似，attachEvent（）可以为元素绑定多个方法，不过是后绑定的先运行。</p>
<h3 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h3><p>为了让我们的代码可以在所有浏览器正常运行，我们可以自己编写一个兼容所有浏览器的事件处理程序。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">    <span class="string">'addHandler'</span>:<span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(element.addEventListener)&#123;</div><div class="line">            element.addEventListener(type,handler,<span class="literal">false</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.attachEvent)&#123;</div><div class="line">            element.attachEvent(<span class="string">"on"</span>+type,handler);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            element[<span class="string">"on"</span>+type] = handler;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="string">'removeHandler'</span>:<span class="function"><span class="keyword">function</span>(<span class="params">element,type,handler</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(element.removeEventListener)&#123;</div><div class="line">            element.removeEventListener(type,handler,<span class="literal">false</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(element.detachEvent)&#123;</div><div class="line">            element.detachEvent(<span class="string">"on"</span>+type,handler);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            element[<span class="string">"on"</span>+type] = <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>这算一个比较重要的点了，我们触发某个事件时，会产生一个事件对象event，其中包含着所有与时间有关的信息，如事件的类型，事件的目标（事件委托应用到），以及与特定事件相关的信息。例如，鼠标事件中，有包含鼠标位置的信息，键盘事件中则包含于按键相关的信息。浏览器虽然都支持event对象，但支持方式不尽相同。</p>
<h3 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h3><p>当触发了事件时，兼容DOM的浏览器都自动会给我们的事件处理程序传入一个event对象，我们要做的只是在声明监听函数的时候加上一个event参数以便浏览器传入就ok了，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">btn.addEventListener = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面列举type的属性及方法：</p>
<ul>
<li>type：事件类型</li>
<li>bubbles：表明事件是否可以冒泡</li>
<li>cancelable：表明是否可以阻止默认事件</li>
<li>currentTarget：事件处理程序当前正在处理的元素，通常用target较多</li>
<li>preventDefault（）：取消事件的默认行为，需要cancelable属性为True方可用，可用来定制自己的处理行为</li>
<li>stopPropagation（）：取消事件的进一步捕获或者冒泡，需要bubbles为True方可用</li>
<li>target：事件的真正目标</li>
<li>eventPhase：确定事件当前正处于事件流的哪个阶段，1代表处于捕获阶段，2代表处于目标对象上，3代表处于冒泡阶段</li>
</ul>
<blockquote>
<p>在事件处理程序内部，this始终等于currentTarget的值，如果不使用事件委托，那么this，currentTarget，target的值相同.</p>
</blockquote>
<h3 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h3><p>访问IE中的event的方式有几种，取决于绑定监听函数的方式。</p>
<p>如果是使用DOM0级方法添加的事件监听函数，那么event对象会作为window对象的一个属性存在。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"button1"</span>);</div><div class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> event = <span class="built_in">window</span>.event;</div><div class="line">    <span class="built_in">console</span>.log(event.type);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果通过attachEevent方法来绑定监听函数，那么event对象会自动传入我们我们的事件处理函数中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"button1"</span>);</div><div class="line">btn.attachEvent(<span class="string">"onclick"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.type);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>同样，IE下的event对象也有一些属性和方法，大多都与DOM下的event属性方法对应：</p>
<ul>
<li>cancelBubble：取消冒泡，默认为false，与stopPropagation（）对应</li>
<li>returnValue：默认为true，置为false可阻止默认事件，与preventDefault（）对应</li>
<li>srcElement：与Dom中的target属性对应</li>
<li>type：同DOM下的type</li>
</ul>
<blockquote>
<p>IE中事件处理程序中的this会随绑定方式的不同而变化，所以最好使用srcElement比较稳妥。</p>
</blockquote>
<h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><p>下面来实现事件对象的兼容写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> eventUtil = &#123;</div><div class="line">    getEvent：<span class="function"><span class="keyword">function</span>（<span class="title">event</span>）</span>&#123;</div><div class="line">        <span class="keyword">return</span> event?event:<span class="built_in">window</span>.event;</div><div class="line">    &#125;</div><div class="line">    getTarget:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> event.target || event.srcElement;</div><div class="line">    &#125;</div><div class="line">    preDefault:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(event.preventDefault)&#123;</div><div class="line">            event.preventDefault();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            event.returnValue = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    stopPropagation:<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">        <span class="keyword">if</span>(event.stopPropagation)&#123;</div><div class="line">            event.stopPropagation();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            event.cancelBubble = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><p>介绍完基本的事件监听函数和事件对象，接下来就应该介绍种类繁多的事件类型及应用了。</p>
<p>DOM3级事件规定了一下事件：</p>
<ul>
<li>UI（user Interface）事件，用户与元素交互时触发</li>
<li>焦点事件，元素获取或失去焦点时触发</li>
<li>鼠标事件，通过鼠标执行操作时触发</li>
<li>滚轮事件，使用滚轮时触发</li>
<li>文本事件，在文档中输入文本时触发</li>
<li>键盘事件，在键盘上执行操作触发</li>
<li>合成事件，在IME（输入法编辑器）输入字符触发</li>
<li>变动事件，底层DOM结构发生变化时触发</li>
</ul>
<p>包括IE9在内的主流浏览器斗殴支持DOM2级事件，IE9也支持DOM3事件</p>
<h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><p>UI事件指的并不一定是与用户操作有关的事件，较常用的有：</p>
<ul>
<li>load：页面完全加载后在window上触发，当所有框架加载完在框架集上触发，当图像加载完毕是在img元素上触发</li>
<li>unload：与上面类似，只不过是在写在的时候触发</li>
<li>select：用户选择文本框中的字符时触发。</li>
<li>resize：当窗口或框架大小发生改变时触发</li>
<li>scroll：用户滚动带滚动条的元素中的内容时触发</li>
</ul>
<p>这些事件都可以用HTML事件处理程序的方式实现。</p>
<blockquote>
<p>根据DOM级事件规范，我们应该在document上处理load事件，但实际上所有浏览器在window上都实现了该事件，确保向后兼容。</p>
</blockquote>
<h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><p>焦点事件与document.hasFocus（）及document.activeElement属性配合，可以知道用户在页面上的行踪。</p>
<p>焦点事件有以下这些：</p>
<ul>
<li>blur：元素失去焦点时触发，不会冒泡</li>
<li>focus：元素获取焦点是触发，不会冒泡</li>
<li>focusin：元素获取焦点时触发，冒泡，除了FF外基本都支持（DOM3）</li>
<li>focusout：元素失去焦点触发，冒泡，除了FF外基本都支持（DOM3）</li>
<li>DOMFocusOut：只有Opera支持，与focusout等价</li>
<li>DOMFocusIn：只有Opera支持，与focusin等价</li>
</ul>
<p>在页面中当焦点从一个元素移到另一个焦点上时，事件的触发顺序是这样的：</p>
<ol><br><li>focusout在失去焦点的元素上触发</li><br><li>focusin在获得焦点的元素上触发</li><br><li>blur在失去焦点的元素上触发</li><br><li>DOMFocusOut在失去焦点的元素上触发</li><br><li>focus在获得焦点的元素上触发</li><br><li>DOMFoucusIn在获得焦点的元素上触发</li><br></ol>

<p>要确定浏览器是否支持dom3的焦点事件，可以用以下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isSupported = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"focusEvent"</span>,<span class="string">"3.0"</span>);</div></pre></td></tr></table></figure>
<h3 id="鼠标和滚轮事件"><a href="#鼠标和滚轮事件" class="headerlink" title="鼠标和滚轮事件"></a>鼠标和滚轮事件</h3><p>网页中用户大多的操作行为都是通过鼠标来实现的，DOM3级中实现了9个鼠标事件：</p>
<ul>
<li>click：用户单击鼠标左键和enter键时触发</li>
<li>dblclick：用户双击鼠标左键时触发，DOM3将它纳入了标准</li>
<li>mousedown:用户按下鼠标按钮还没放开时触发</li>
<li>mouseup：用户释放鼠标按钮时触发</li>
<li>mouseenter：鼠标光标首次移进目标元素内触发，此事件不冒泡，移进后代元素不会触发，DOM3将它纳入了标准</li>
<li>mouseoutleave：鼠标光标移到元素范围之外时触发，事件不冒泡，移进后代元素不会触发，DOM3将它纳入了标准</li>
<li>onmouseover：鼠标光标首次移进目标元素内触发，移进后代会触发</li>
<li>onmouseover：鼠标光标移出目标元素内触发，移进后代会触发</li>
</ul>
<blockquote>
<p>总结：除mouseenter和mouseleave外，其他函数都会冒泡，也可以被取消默认行为。只有相继触发mousedown和onmouseup才会触发click事件。连续两次触发click才会引发dblclick事件。</p>
</blockquote>
<p>这四个事件触发的先后顺序如下：</p>
<ol><br>    <li>mousedown</li><br>    <li>mouseup</li><br>    <li>click</li><br>    <li>mousedown</li><br>    <li>mouseup</li><br>    <li>click</li><br>    <li>dblclick</li><br><br></ol>

<p>要确定浏览器是否支持DOM3和DOM3的鼠标事件，可以用以下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isSupported2 = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvents"</span>,<span class="string">"2.0"</span>);</div><div class="line"><span class="keyword">var</span> isSupported3 = <span class="built_in">document</span>.implementation.hasFeature(<span class="string">"MouseEvent"</span>,<span class="string">"2.0"</span>);</div></pre></td></tr></table></figure>
<h4 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件"></a>滚轮事件</h4><p>鼠标能触发的还有一个滚轮事件，mousewheel，其实之前的博客中已经做了详细的介绍了。</p>
<p>鼠标事件中事件对象具有以下属性：</p>
<ul>
<li>clientX：事件发生时鼠标在视口中的水平坐标</li>
<li>clientY：事件发生时鼠标在视口中的垂直坐标</li>
<li>pageX：事件发生时鼠标在页面中的水平坐标（包含了滚动的距离）</li>
<li><p>pageY：事件发生时鼠标在页面中的垂直坐标（包含了滚动的距离）</p>
<p>  以pageY为例，使用clientY和滚动信息就可以计算出pageY，这里我们需要通过document.body(混杂模式)和document.documentElement(标准模式)中的scrollLeft和scrollTop。</p>
<p>  pageY = event.clientY + document.body.scrollTop || document.documentElement.scrollTop</p>
</li>
<li>screenX:事件发生时鼠标距离屏幕左边的距离</li>
<li>screenY：事件发生时鼠标距离屏幕上方的距离</li>
<li><p>修改键：</p>
<ul>
<li>有时我们会结合键盘和鼠标来修改鼠标事件，这时就要使用类似Shift、Ctrl、Alt和Meta之类的修改键了，有4个表示这些修改键状态的属性：<ul>
<li>shiftKey</li>
<li>ctrlKey</li>
<li>altKey</li>
<li>metaKey</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>mousewheel事件触发后，会冒泡到document或者window，此外，该事件对应的事件对象中有一个wheelDelta属性，当滑轮<strong>向上滚</strong>是，该属性值是<strong>120的倍数</strong>；<strong>向下滚时</strong>，该属性值是<strong>-120的倍数</strong>.<br>FF（fireFox）还支持一个DOMMouseScroll事件，与mousewheel类似，只不过该事件的信息存放在event.detail(<strong>Opera也是</strong>)中，属性值为-3的倍数时，为滑轮向前滚；为3的倍数时，为滑轮向后滚。</p>
</blockquote>
<p>为避免篇幅过长，其它事件在下一篇博客进行介绍。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://og48zuyzv.bkt.clouddn.com/t01fad4ace94b4e1dd0.jpg"
               alt="Liby" />
          <p class="site-author-name" itemprop="name">Liby</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Wangjunyu" target="_blank" title="github">
                  
                  github
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://web.umeng.com" title="CNZZ" target="_blank">CNZZ</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://tongji.baidu.com/" title="百度统计" target="_blank">百度统计</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://leancloud.cn" title="leancloud" target="_blank">leancloud</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://analytics.google.com" title="Google分析" target="_blank">Google分析</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://theme-next.iissnan.com/" title="Next主题配置文档" target="_blank">Next主题配置文档</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://hexo.io/docs/" title="Hexo官方配置文档" target="_blank">Hexo官方配置文档</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Liby</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  






  





  

  

  

  

</body>
</html>
